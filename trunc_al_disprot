function [alg,ats,strseqnum,selectedpos]=trunc_al_disprot(algn,disprot)
%
% Usage: [alg,dist,ats,strseqnum,selectedpos]=trunc_al(algn,pdb,chain);
%
% This function carries out initial alignment conditioning and truncation
% based on a reference sequence with known three-dimensional structure (pdb
% and chain). Note: The alignment should contain the reference sequence.
% The program outputs (1) alg, the truncated conditioned alignment, (2)
% dist, a matrix of distances between all pairs of residues in the 3D
% structure (calculated as the minimal distance between all constituent
% atoms for each pair of residues), (3) ats, a list of position labels for
% the reference sequence, (4) strseqnum, the position of the reference
% sequence in the original alignment algn (note that this program moves the
% reference sequence to the first row of the output alignment alg), and (5)
% selectedpos, indices of the positions in algn retained in alg.
%


% Extracts distance matrix, sequence and labels from pdb files:
seq_pdb=disprot.Sequence;
x=1:length(disprot.Sequence);
for i=1:length(x);
    ats{i}=[num2str(x(i)) ''];
end;

% Finds the sequence in the alignment that is closest to the pdb sequence:
if isstruct(algn), hd={algn.Header}; algn=char({algn.Sequence}); end
algn=clean_al(algn); % see below
strseqnum=MSAsearch(disprot,algn,1,0);

% Truncates the positions based on the closest sequence:
selectedpos=1:numel(algn(1,:));
selectedpos=selectedpos(algn(strseqnum,:)~='-');
algn_tr=algn(:,selectedpos);

% Puts the closest sequence in first position:
algn_tr([1 strseqnum],:)=algn_tr([strseqnum 1],:);
seq_alg=algn_tr(1,:);
hd([1 strseqnum])=hd([strseqnum 1]); 

% The sequence in pdb, 'seq_pdb', is generally not strictly identical to
% the sequence in the alignment, 'seq_alg': the sequence in the pdb may
% start and end at different positions and may miss some positions.

% Removes differences at the start of the sequences:
[sc,al,start]=swalign(seq_pdb,seq_alg);
selpos_pdb=start(1):numel(seq_pdb);
seq_pdb_tr=seq_pdb(selpos_pdb);
selpos_alg=start(2):numel(seq_alg);
seq_alg_tr=seq_alg(selpos_alg);

% Removes positions with gaps in seq_pdb or in alignment:
[sc,al]=swalign(seq_pdb_tr,seq_alg_tr);

nogap_pdb=zeros(1,size(al,2));
nogap_pdb(al(3,:)~='-')=1:min(numel(seq_alg_tr),sum(al(3,:)~='-'));
nogap_pdb(al(1,:)=='-')=0;
nogap_pdb(nogap_pdb==0)=[];
selpos_alg=selpos_alg(nogap_pdb);

nogap_alg=zeros(1,size(al,2));
%nogap_alg(al(1,:)~='-')=1:min(numel(seq_pdb_tr),size(al,2));
nogap_alg(al(1,:)~='-')=1:min(numel(seq_pdb_tr),sum(al(1,:)~='-'));
nogap_alg(al(3,:)=='-')=0;
nogap_alg(nogap_alg==0)=[];
selpos_pdb=selpos_pdb(nogap_alg);


% Removes differences at the end of the sequences:
minL=min(numel(selpos_pdb,selpos_alg));
selpos_pdb=selpos_pdb(1:minL);
selpos_alg=selpos_alg(1:minL);

% Final selection of positions:
selectedpos=selectedpos(selpos_alg);
ats=ats(selpos_pdb);
alg.Sequence=algn_tr(:,selpos_alg);
alg.Header=hd;

% Checks the result and displays any remaining difference:
similarity=sum(seq_pdb(selpos_pdb)==seq_alg(selpos_alg))/minL;
if similarity<1
    disp(['Warning: the matching structure-alignment is not perfect (similarity = ' num2str(similarity,2) ')']);
    disp(seq_pdb(selpos_pdb));
    disp(algn_tr(1,selpos_alg));
end

function alg=clean_al(alg)
% Replaces any character that is not a valid amino acid by a gap
code='ACDEFGHIKLMNPQRSTVWY';
[irrelevant,indices]=setdiff(alg(:),code);
alg(indices)='-';

function [strseqnum,ats,best_align,alignment_trunc]=MSAsearch(disprot,alignment,...
                                                              ats_or_not, truncate_or_not)
% This function makes pairwise alignments between a query sequence (from
% the pdb file and chain ID) and every sequence in an MSA (alignment),and
% finds the tophit sequence. If ats_or_not is set to one, it then attempts to make a residue number
% list (ats) that relates alignment numbering to structure numbering.  The
% function expects certain fields to exist in the pdb file that comprise
% the standard pdb format according to the pdb.org. The function is
% therefore NOT guaranteed to work for user-specific or other non-standard
% pdb formats.
%
% The default usage of this function is to read in a pdb structure file
% using getpdb.m or readpdb.m (functions in the biofinformatics toolbox)
% and then just make the residue number list (ats).  An alternative usage
% (by passing truncate_or_not=1) is to both make the residue number list
% (ats) and to truncate the MSA to the pdb sequence (returned in
% alignment_trunc).
%
% Arguments:
%
% Takes in:
%           (1) pdb, in pdb.org format (2) chainID, the particular sequence
%           to be used for truncation (3) alignment, the MSA 
%           (4) ats_or_not... 1 to construct the ats, 0 to not
%           (5) truncate_or_not...1 to truncate to pdb, 0 to not.
% Returns:
%           (1) strseqnum, the MSA sequence number used for truncation (2)
%           ats, the residue position numbering according to the query
%           sequence, (3) best_align, the tophit pairwise alignment (4)
%           alignment_trunc, the truncated alignment if relevant.
%
%
% Authors: Rama Ranganathan (rama.ranganathan@UTSouthwestern.edu)
%          Rohit Sharma
%          Kimberly Reynolds (kimberly.reynolds@utsouthwestern.edu)
%
% modified 1/2010 by R.R
% modified 2/2011 by Kim Reynolds
%
% Copyright R.Ranganathan 1999-2011
%**************************************************************************

% preliminaries
[x,y]=size(alignment);
if nargin <4
    ats_or_not = 0;
    truncate_or_not=0;
elseif nargin < 5
    truncate_or_not =0;
end

AA(1,:)={'ALA' 'ARG'  'ASN'  'ASP'  'CYS'  'GLN'  'GLU'  'GLY'  'HIS'  'ILE'...
    'LEU'  'LYS'  'MET'  'PHE'  'PRO'  'SER'  'THR'  'TRP'  'TYR'  'VAL'  'ASX'...
    'GLX'  'XAA'  'END' 'GAP'};
AA(2,:)={'A' 'R'  'N'  'D'  'C'  'Q'  'E'  'G'  'H'  'I'  'L'  'K'  'M'  'F'...
    'P'  'S'  'T'  'W'  'Y'  'V'  'B'  'Z'  'X'  '*' '-'};

seq_pdb=disprot.Sequence;
x=1:length(disprot.Sequence);
for i=1:length(x);
    ats{i}=[num2str(x(i)) ''];
end;
resnumlist=ats';
aa_model=seq_pdb;


aam_tmp=num2cell(aa_model);
aa_model=cell2mat(aam_tmp);

% score each alignment sequence (removed of gaps) to the pdb sequence and
% find the tophit sequence to make the residue number list.  The typical
% expectation is that the pdb sequence is actually in the aligment and so
% we will find a 100% (or nearly 100%) match.

scores = zeros(1,size(alignment,1));

for rownum = 1:size(alignment,1)
    [scores(rownum),junk] = swalign(alignment(rownum,find(isletter(alignment(rownum,:)))), aa_model(isletter(aa_model)));
end
strseqnum = find(scores == max(scores));
if size(strseqnum,2) > 1
    strseqnum = strseqnum(1);
end

if ats_or_not == 1
    % Now we make the ats either with or without alignment truncation
    if truncate_or_not==1
        alignment_trunc = alignment(:,find(isletter(alignment(strseqnum,:))));
        %disp(['     truncated alignment using sequence #' num2str(strseqnum) '  (score: ' num2str(max(scores)) ')']);
        [topscore, best_align, startat] = swalign(alignment_trunc(strseqnum,:), aa_model(isletter(aa_model)));
        %best_align
        %disp([' size of best_align is:  ' num2str(size(best_align,2))]);
        k=0;
        ats=cell(1,size(best_align,2));
        ats(1)=resnumlist(startat(2));
        for i=2:size(best_align,2);
            if best_align(2,i)=='|'|best_align(2,i)==':'
                k=k+1;
                ats(i)=resnumlist(startat(2)+k);
            elseif best_align(2,i)==' '& isletter(best_align(3,i))
                k=k+1;
                ats(i)=resnumlist(startat(2)+k);
            end
        end
        
    else
        [topscore, best_align, startat] = swalign(alignment(strseqnum,:), aa_model(isletter(aa_model)));
        %disp(['tophit is sequence #' num2str(strseqnum) '  (score: ' num2str(max(scores)) ')']);
        %best_align
        %disp([' size of best_align is:  ' num2str(size(best_align,2))]);
        k=0;
        ats=cell(1,size(best_align,2));
        ats(1)=resnumlist(startat(2));
        for i=2:size(best_align,2);
            if best_align(2,i)=='|'|best_align(2,i)==':'
                k=k+1;
                ats(i)=resnumlist(startat(2)+k);
            elseif best_align(2,i)==' '& isletter(best_align(3,i))
                k=k+1;
                ats(i)=resnumlist(startat(2)+k);
            end
        end
        
    end
    
    % now fix inconsistencies between the MSA and pairwise alignment that are
    % inevitable since the ats is made from a pairwise alignment of the
    % selected sequence from the MSA and the pdb sequence.  We do this by aia
    % slightly bizarre way.  We make a profile of the pairwise alignemnt of the
    % selected sequence from the MSA and the pdb model, and make a profile of
    % the selected sequence as it exists in the MSA, and then make a profile to
    % profile alignment.
    pf_1=seqprofile([best_align(1,:);best_align(3,:)]);
    pf_2=seqprofile([alignment(strseqnum,:)]);
    [prof,h1,h2]=profalign(pf_1,pf_2);
    %old version:
    %ats = ats(h2);
    
    %ok... now - lets make a new ats.
    %positions present in h2 (the alignment sequence), but not h1,
    %should get assigned as gaps in the ats.
    atsnew = cell(1,size(alignment,2));
    atsnew(find(~ismember(h2,h1))) = cellstr(' ');
    %things which are present in both h1 and h2 should get assigned from the
    %previously constructed ats.
    [isec, ia, ib] = intersect(h1,h2);
    atsnew(ib) = ats(ia);
    %note that things in h1 (the pdb sequence), but not in h2, should be left
    %out of the ats, since they are (presumably) positions not
    %present/truncated out of the alignment.
    ats=atsnew;
end
